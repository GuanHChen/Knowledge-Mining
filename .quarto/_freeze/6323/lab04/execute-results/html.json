{
  "hash": "0bedb6202a9e674aafe17948dbf9be0a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Knowledge Mining: Lab04 R programming (Unsupervised learning)\"\nauthor: \"Guan Chen\"\noutput: \n  html_document: \n    toc: yes\n    toc_float: yes\n    highlight: default\n    theme: libera\n    number_sections: yes\ndate: last-modified \ntitle-block-banner: true\n---\n\n\n# Unsupervised Learning\n\nUnsupervised learning is a class of machine learning algorithms to identify patterns or grouping structure in the data. Unlike supervised learning which relies on \"supervised\" information such as the dependent variable to guide modeling, unsupervised learning seeks to explore the structure and possible groupings of unlabeled data. This information will be useful to provide pre-processor for supervised learning.\n\nUnsupervised learning has no explicit dependent variable of Y for prediction. Instead, the goal is to discover interesting patterns about the measurements on $(X_{1}), (X_{2}), . . . , (X_{p})$ and identify any subgroups among the observations.\n\nGenerally, in this section, the two general methods are introduced: Principal components analysis and Clustering.\n\n## Principal Component Analysis (PCA)\n\nPrincipal Components Analysis (PCA) produces a low-dimensional representation of a dataset. It finds a sequence of linear combinations of the variables that have maximal variance, and are mutually uncorrelated.\n\nThe first principal component of a set of features $(X_1, X_2, . . . , X_p)$ is the normalized linear combination of the features: <br> $$  Z_1 = \\phi_{11}X_1 +\\phi_{21}X_2 +...+\\phi_{p1}X_p $$ <br>\n\nthat has the largest variance. By normalized, we mean that $\\sum_{j=1}^p\\phi_{j1}^2 = 1$.\n\nThe elements $(\\phi_{11}, . . . , \\phi_{p1})$ are the loadings of the first principal component; together, the loadings make up the principal component loading vector, $\\phi_1= (\\phi_{11} \\phi_{21} ... \\phi_{p1})^T$\n\nWe constrain the loadings so that their sum of squares is equal to one, since otherwise setting these elements to be arbitrarily large in absolute value could result in an arbitrarily large variance.\n\n## Clustering\n\n### K-Means Clustering\n\nThe K-means clustering method is to partition the data points into k groups such that the sum of squares from points to the assigned cluster center in each group is minimized.\n\n### Hierarchical Clustering\n\nHierarchical clustering is an alternative approach which does not require a pre-specified or a particular choice of $(K)$.\n\nHierarchical Clustering has an advantage that it produces a tree-based representation of the observations: Dendrogram\n\nA dendrogram is built starting from the leaves and combining clusters up to the trunk. The result of hierarchical clustering is a tree-based representation of the objects, which is also known as dendrogram. Observations can be subdivided into groups by cutting the dendrogram at a desired similarity level.\n\n# Hands-on workshop: Principal Component Analysis and Clustering methods\n\n\n\n\n\n**1. Principal Component Analysis (PCA)**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Gentle Machine Learning\n## Principal Component Analysis\n\n\n# Dataset: USArrests is the sample dataset used in \n# McNeil, D. R. (1977) Interactive Data Analysis. New York: Wiley.\n# Murder\tnumeric\tMurder arrests (per 100,000)\n# Assault\tnumeric\tAssault arrests (per 100,000)\n# UrbanPop\tnumeric\tPercent urban population\n# Rape\tnumeric\tRape arrests (per 100,000)\n# For each of the fifty states in the United States, the dataset contains the number \n# of arrests per 100,000 residents for each of three crimes: Assault, Murder, and Rape. \n# UrbanPop is the percent of the population in each state living in urban areas.\nlibrary(datasets)\nlibrary(ISLR)\narrest = USArrests\nstates=row.names(USArrests)\nnames(USArrests)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Murder\"   \"Assault\"  \"UrbanPop\" \"Rape\"    \n```\n\n\n:::\n\n```{.r .cell-code}\n# Get means and variances of variables\napply(USArrests, 2, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Murder  Assault UrbanPop     Rape \n   7.788  170.760   65.540   21.232 \n```\n\n\n:::\n\n```{.r .cell-code}\napply(USArrests, 2, var)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Murder    Assault   UrbanPop       Rape \n  18.97047 6945.16571  209.51878   87.72916 \n```\n\n\n:::\n\n```{.r .cell-code}\n# PCA with scaling\npr.out=prcomp(USArrests, scale=TRUE)\nnames(pr.out) # Five\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"sdev\"     \"rotation\" \"center\"   \"scale\"    \"x\"       \n```\n\n\n:::\n\n```{.r .cell-code}\npr.out$center # the centering and scaling used (means)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Murder  Assault UrbanPop     Rape \n   7.788  170.760   65.540   21.232 \n```\n\n\n:::\n\n```{.r .cell-code}\npr.out$scale # the matrix of variable loadings (eigenvectors)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Murder   Assault  UrbanPop      Rape \n 4.355510 83.337661 14.474763  9.366385 \n```\n\n\n:::\n\n```{.r .cell-code}\npr.out$rotation\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                PC1        PC2        PC3         PC4\nMurder   -0.5358995 -0.4181809  0.3412327  0.64922780\nAssault  -0.5831836 -0.1879856  0.2681484 -0.74340748\nUrbanPop -0.2781909  0.8728062  0.3780158  0.13387773\nRape     -0.5434321  0.1673186 -0.8177779  0.08902432\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(pr.out$x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 50  4\n```\n\n\n:::\n\n```{.r .cell-code}\npr.out$rotation=-pr.out$rotation\npr.out$x=-pr.out$x\nbiplot(pr.out, scale=0)\n```\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n\n```{.r .cell-code}\npr.out$sdev\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.5748783 0.9948694 0.5971291 0.4164494\n```\n\n\n:::\n\n```{.r .cell-code}\npr.var=pr.out$sdev^2\npr.var\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.4802416 0.9897652 0.3565632 0.1734301\n```\n\n\n:::\n\n```{.r .cell-code}\npve=pr.var/sum(pr.var)\npve\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.62006039 0.24744129 0.08914080 0.04335752\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(pve, xlab=\"Principal Component\", ylab=\"Proportion of Variance Explained\", ylim=c(0,1),type='b')\n```\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-1-2.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(cumsum(pve), xlab=\"Principal Component\", ylab=\"Cumulative Proportion of Variance Explained\", ylim=c(0,1),type='b')\n```\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-1-3.png){width=672}\n:::\n\n```{.r .cell-code}\n## Use factoextra package\nlibrary(factoextra)\nfviz(pr.out, \"ind\", geom = \"auto\", mean.point = TRUE, font.family = \"Georgia\")\n```\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-1-4.png){width=672}\n:::\n\n```{.r .cell-code}\nfviz_pca_biplot(pr.out, font.family = \"Georgia\", col.var=\"firebrick1\")\n```\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-1-5.png){width=672}\n:::\n:::\n\n\n**2. K-Means Clustering**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Computer purchase example: Animated illustration \n## Adapted from Guru99 tutorial (https://www.guru99.com/r-k-means-clustering.html)\n## Dataset: characteristics of computers purchased.\n## Variables used: RAM size, Harddrive size\n\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(RColorBrewer)\n\ncomputers = read.csv(\"https://raw.githubusercontent.com/guru99-edu/R-Programming/master/computers.csv\") \n\n# Only retain two variables for illustration\nrescaled_comp <- computers[4:5] %>%\n  mutate(hd_scal = scale(hd),\n         ram_scal = scale(ram)) %>%\n  select(c(hd_scal, ram_scal))\n        \nggplot(data = rescaled_comp, aes(x = hd_scal, y = ram_scal)) +\n  geom_point(pch=20, col = \"blue\") + theme_bw() +\n  labs(x = \"Hard drive size (Scaled)\", y =\"RAM size (Scaled)\" ) +\n  theme(text = element_text(family=\"Georgia\")) \n```\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# install.packages(\"animation\")\nlibrary(animation)\nset.seed(2345)\nlibrary(animation)\n\n# Animate the K-mean clustering process, cluster no. = 4\nkmeans.ani(rescaled_comp[1:2], centers = 4, pch = 15:18, col = 1:4) \n```\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-2-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-2-3.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-2-4.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-2-5.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-2-6.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-2-7.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-2-8.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-2-9.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-2-10.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-2-11.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsaveGIF(\n  kmeans.ani(rescaled_comp[1:2], centers = 4, pch = 15:18, col = 1:4) ,\n  movie.name = \"kmeans_animated.gif\",\n  img.name = \"kmeans\",\n  convert = \"magick\",\n  cmd.fun,\n  clean = TRUE,\n  extra.opts = \"\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n![animated K-means output](https://datageneration.io/Gentlemachinelearning/images/kmeans_animated.gif){width=\"700\" height=\"500\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Iris example\n\n# Without grouping by species\nggplot(iris, aes(Petal.Length, Petal.Width)) + geom_point() + \n  theme_bw() +\n  scale_color_manual(values=c(\"firebrick1\",\"forestgreen\",\"darkblue\"))\n```\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# With grouping by species\nggplot(iris, aes(Petal.Length, Petal.Width, color = Species)) + geom_point() + \n  theme_bw() +\n  scale_color_manual(values=c(\"firebrick1\",\"forestgreen\",\"darkblue\"))\n```\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-4-2.png){width=672}\n:::\n\n```{.r .cell-code}\n# Check k-means clusters\n## Starting with three clusters and 20 initial configurations\nset.seed(20)\nirisCluster <- kmeans(iris[, 3:4], 3, nstart = 20)\nirisCluster\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nK-means clustering with 3 clusters of sizes 50, 48, 52\n\nCluster means:\n  Petal.Length Petal.Width\n1     1.462000    0.246000\n2     5.595833    2.037500\n3     4.269231    1.342308\n\nClustering vector:\n  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n [38] 1 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n [75] 3 3 3 2 3 3 3 3 3 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 2 2 2 2 2 2 3 2 2 2 2\n[112] 2 2 2 2 2 2 2 2 3 2 2 2 2 2 2 3 2 2 2 2 2 2 2 2 2 2 2 3 2 2 2 2 2 2 2 2 2\n[149] 2 2\n\nWithin cluster sum of squares by cluster:\n[1]  2.02200 16.29167 13.05769\n (between_SS / total_SS =  94.3 %)\n\nAvailable components:\n\n[1] \"cluster\"      \"centers\"      \"totss\"        \"withinss\"     \"tot.withinss\"\n[6] \"betweenss\"    \"size\"         \"iter\"         \"ifault\"      \n```\n\n\n:::\n\n```{.r .cell-code}\nclass(irisCluster$cluster)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Confusion matrix\ntable(irisCluster$cluster, iris$Species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   \n    setosa versicolor virginica\n  1     50          0         0\n  2      0          2        46\n  3      0         48         4\n```\n\n\n:::\n\n```{.r .cell-code}\nirisCluster$cluster <- as.factor(irisCluster$cluster)\nggplot(iris, aes(Petal.Length, Petal.Width, color = irisCluster$cluster)) + geom_point() +\n  scale_color_manual(values=c(\"firebrick1\",\"forestgreen\",\"darkblue\")) +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-4-3.png){width=672}\n:::\n\n```{.r .cell-code}\nactual = ggplot(iris, aes(Petal.Length, Petal.Width, color = Species)) + geom_point() + \n  theme_bw() +\n  scale_color_manual(values=c(\"firebrick1\",\"forestgreen\",\"darkblue\")) +\n  theme(legend.position=\"bottom\") +\n  theme(text = element_text(family=\"Georgia\")) \nkmc = ggplot(iris, aes(Petal.Length, Petal.Width, color = irisCluster$cluster)) + geom_point() +\n  theme_bw() +\n  scale_color_manual(values=c(\"firebrick1\", \"darkblue\", \"forestgreen\")) +\n  theme(legend.position=\"bottom\") +\n  theme(text = element_text(family=\"Georgia\")) \nlibrary(grid)\nlibrary(gridExtra)\ngrid.arrange(arrangeGrob(actual, kmc, ncol=2, widths=c(1,1)), nrow=1)\n```\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-4-4.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Wine example\n\n# The wine dataset contains the results of a chemical analysis of wines \n# grown in a specific area of Italy. Three types of wine are represented in the \n# 178 samples, with the results of 13 chemical analyses recorded for each sample. \n# Variables used in this example:\n# Alcohol\n# Malic: Malic acid\n# Ash\n# Source: http://archive.ics.uci.edu/ml/datasets/Wine\n\n# Import wine dataset\nlibrary(readr)\nwine <- read_csv(\"https://raw.githubusercontent.com/datageneration/gentlemachinelearning/master/data/wine.csv\")\n\n\n## Choose and scale variables\nwine_subset <- scale(wine[ , c(2:4)])\n\n## Create cluster using k-means, k = 3, with 25 initial configurations\nwine_cluster <- kmeans(wine_subset, centers = 3,\n                       iter.max = 10,\n                       nstart = 25)\nwine_cluster\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nK-means clustering with 3 clusters of sizes 48, 60, 70\n\nCluster means:\n     Alcohol      Malic        Ash\n1  0.1470536  1.3907328  0.2534220\n2  0.8914655 -0.4522073  0.5406223\n3 -0.8649501 -0.5660390 -0.6371656\n\nClustering vector:\n  [1] 2 3 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 2 1 2 2 2 2 2 3 2 2 2 2 2 2 2 2 2\n [38] 2 3 1 2 1 2 1 3 1 1 2 2 2 3 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 2 3 3 2 2 2\n [75] 3 3 3 3 3 1 3 3 3 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n[112] 3 1 3 3 3 3 3 1 3 3 2 1 1 1 3 3 3 3 1 3 1 3 1 3 3 1 1 1 1 1 2 1 1 1 1 1 1\n[149] 1 1 1 1 2 1 3 1 1 1 2 2 1 1 1 1 2 1 1 1 2 1 3 3 2 1 1 1 2 1\n\nWithin cluster sum of squares by cluster:\n[1]  73.71460  67.98619 111.63512\n (between_SS / total_SS =  52.3 %)\n\nAvailable components:\n\n[1] \"cluster\"      \"centers\"      \"totss\"        \"withinss\"     \"tot.withinss\"\n[6] \"betweenss\"    \"size\"         \"iter\"         \"ifault\"      \n```\n\n\n:::\n\n```{.r .cell-code}\n# Create a function to compute and plot total within-cluster sum of square (within-ness)\nwssplot <- function(data, nc=15, seed=1234){\n  wss <- (nrow(data)-1)*sum(apply(data,2,var))\n  for (i in 2:nc){\n    set.seed(seed)\n    wss[i] <- sum(kmeans(data, centers=i)$withinss)}\n  plot(1:nc, wss, type=\"b\", xlab=\"Number of Clusters\",\n       ylab=\"Within groups sum of squares\")\n}\n\n# plotting values for each cluster starting from 1 to 9\nwssplot(wine_subset, nc = 9)\n```\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Plot results by dimensions\nwine_cluster$cluster = as.factor(wine_cluster$cluster)\npairs(wine[2:4],\n      col = c(\"firebrick1\", \"darkblue\", \"forestgreen\")[wine_cluster$cluster],\n      pch = c(15:17)[wine_cluster$cluster],\n      main = \"K-Means Clusters: Wine data\")\n```\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-5-2.png){width=672}\n:::\n\n```{.r .cell-code}\ntable(wine_cluster$cluster)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n 1  2  3 \n48 60 70 \n```\n\n\n:::\n\n```{.r .cell-code}\n## Use the factoextra package to do more\n# install.packages(\"factoextra\")\n\nlibrary(factoextra)\nfviz_nbclust(wine_subset, kmeans, method = \"wss\")\n```\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-5-3.png){width=672}\n:::\n\n```{.r .cell-code}\n# Use eclust() procedure to do K-Means\nwine.km <- eclust(wine_subset, \"kmeans\", nboot = 2)\n```\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-5-4.png){width=672}\n:::\n\n```{.r .cell-code}\n# Print result\nwine.km\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nK-means clustering with 3 clusters of sizes 60, 70, 48\n\nCluster means:\n     Alcohol      Malic        Ash\n1  0.8914655 -0.4522073  0.5406223\n2 -0.8649501 -0.5660390 -0.6371656\n3  0.1470536  1.3907328  0.2534220\n\nClustering vector:\n  [1] 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1 3 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1\n [38] 1 2 3 1 3 1 3 2 3 3 1 1 1 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 1 2 2 1 1 1\n [75] 2 2 2 2 2 3 2 2 2 3 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n[112] 2 3 2 2 2 2 2 3 2 2 1 3 3 3 2 2 2 2 3 2 3 2 3 2 2 3 3 3 3 3 1 3 3 3 3 3 3\n[149] 3 3 3 3 1 3 2 3 3 3 1 1 3 3 3 3 1 3 3 3 1 3 2 2 1 3 3 3 1 3\n\nWithin cluster sum of squares by cluster:\n[1]  67.98619 111.63512  73.71460\n (between_SS / total_SS =  52.3 %)\n\nAvailable components:\n\n [1] \"cluster\"      \"centers\"      \"totss\"        \"withinss\"     \"tot.withinss\"\n [6] \"betweenss\"    \"size\"         \"iter\"         \"ifault\"       \"clust_plot\"  \n[11] \"silinfo\"      \"nbclust\"      \"data\"         \"gap_stat\"    \n```\n\n\n:::\n\n```{.r .cell-code}\n# Optimal number of clusters using gap statistics\nwine.km$nbclust\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nfviz_nbclust(wine_subset, kmeans, method = \"gap_stat\")\n```\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-5-5.png){width=672}\n:::\n\n```{.r .cell-code}\n# Silhouette plot\nfviz_silhouette(wine.km)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  cluster size ave.sil.width\n1       1   60          0.44\n2       2   70          0.33\n3       3   48          0.30\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-5-6.png){width=672}\n:::\n\n```{.r .cell-code}\nfviz_cluster(wine_cluster, data = wine_subset) + \n  theme_bw() +\n  theme(text = element_text(family=\"Georgia\")) \n```\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-5-7.png){width=672}\n:::\n\n```{.r .cell-code}\nfviz_cluster(wine_cluster, data = wine_subset, ellipse.type = \"norm\") + \n  theme_bw() +\n  theme(text = element_text(family=\"Georgia\")) \n```\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-5-8.png){width=672}\n:::\n:::\n\n\n**3. Hierarchical Clustering**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Hierarchical Clustering\n## Dataset: USArrests\n#  install.packages(\"cluster\")\narrest.hc <- USArrests %>%\n  scale() %>%                    # Scale all variables\n  dist(method = \"euclidean\") %>% # Euclidean distance for dissimilarity \n  hclust(method = \"ward.D2\")     # Compute hierarchical clustering\n\n# Generate dendrogram using factoextra package\nfviz_dend(arrest.hc, k = 4, # Four groups\n          cex = 0.5, \n          k_colors = c(\"firebrick1\",\"forestgreen\",\"blue\", \"purple\"),\n          color_labels_by_k = TRUE, # color labels by groups\n          rect = TRUE, # Add rectangle (cluster) around groups,\n          main = \"Cluster Dendrogram: USA Arrest data\"\n) + theme(text = element_text(family=\"Georgia\")) \n```\n\n::: {.cell-output-display}\n![](lab04_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nPrincipal Component Analysis (PCA) and clustering methods serve distinct purposes in data analysis. PCA focuses on dimensionality reduction, aiming to simplify complex datasets by transforming the original variables into a new set of orthogonal variables called principal components. In contrast, clustering methods aim to uncover natural groupings within the data by partitioning it into clusters of similar data points based on similarity or distance metrics. While PCA seeks to condense the information within the data, clustering methods facilitate the discovery of inherent structures or patterns by grouping data points with shared characteristics.\n\n\n\n\n\n\n\n**References**\n\nJames, Gareth, Daniela Witten, Trevor Hastie, and Robert Tibshirani. 2013 *An introduction to statistical learning*. Vol. 112. New York: Springer.\n",
    "supporting": [
      "lab04_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}